name: Deploy Pipeline

on:
  workflow_dispatch:
    inputs:
      workflows:
        description: 'JSON array of workflow filenames to trigger'
        required: true
        type: string
      content_sha:
        description: 'Content repo SHA being deployed'
        required: true
        type: string

jobs:
  staging:
    runs-on: ubuntu-latest
    env:
      GH_REPO: ${{ github.repository }}   # gives gh CLI repo context without a checkout
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Trigger staging deployments
        id: trigger_staging
        run: |
          set -eo pipefail
          WORKFLOWS='${{ github.event.inputs.workflows }}'
          COUNT=$(echo "$WORKFLOWS" | jq length)
          echo "Triggering $COUNT workflow(s) to staging..."

          # Record timestamp just before triggering so the poller can filter stale runs
          TRIGGER_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "trigger_time=$TRIGGER_TIME" >> $GITHUB_OUTPUT

          readarray -t WF_ARRAY < <(echo "$WORKFLOWS" | jq -r '.[]')
          for wf in "${WF_ARRAY[@]}"; do
            echo "Triggering staging: $wf"
            gh workflow run "$wf" --field environment=staging \
              || { echo "FATAL: Failed to trigger $wf — aborting"; exit 1; }
            echo "  -> Triggered OK"
            sleep 5
          done

      - name: Wait for all staging runs to complete
        run: |
          set -eo pipefail
          WORKFLOWS='${{ github.event.inputs.workflows }}'
          TRIGGER_TIME='${{ steps.trigger_staging.outputs.trigger_time }}'
          POLL_INTERVAL=60
          TIMEOUT=5400  # 90 minutes max per workflow

          echo "Waiting 90s for staging runs to appear..."
          sleep 90

          readarray -t WF_ARRAY < <(echo "$WORKFLOWS" | jq -r '.[]')
          for wf in "${WF_ARRAY[@]}"; do
            echo "--- Polling: $wf (runs created after $TRIGGER_TIME) ---"
            ELAPSED=90  # already waited 90s

            while [ $ELAPSED -lt $TIMEOUT ]; do
              # Filter to only runs created at or after our trigger timestamp
              RUN_JSON=$(gh run list --workflow="$wf" --limit 5 \
                --json status,conclusion,databaseId,createdAt 2>/dev/null \
                | jq --arg since "$TRIGGER_TIME" \
                    '[.[] | select(.createdAt >= $since)]' \
                || echo "[]")

              if [ "$RUN_JSON" = "[]" ] || [ "$(echo "$RUN_JSON" | jq length)" = "0" ]; then
                echo "  Run not visible yet (elapsed ${ELAPSED}s)..."
                sleep $POLL_INTERVAL
                ELAPSED=$((ELAPSED + POLL_INTERVAL))
                continue
              fi

              STATUS=$(echo "$RUN_JSON" | jq -r '.[0].status')
              RUN_ID=$(echo "$RUN_JSON" | jq -r '.[0].databaseId')

              if [ "$STATUS" = "completed" ]; then
                CONCLUSION=$(echo "$RUN_JSON" | jq -r '.[0].conclusion')
                if [ "$CONCLUSION" = "success" ]; then
                  echo "  Staging PASSED: $wf (run $RUN_ID)"
                else
                  echo "  Staging FAILED: $wf (run $RUN_ID, conclusion: $CONCLUSION)"
                  exit 1
                fi
                break
              fi

              echo "  Status: $STATUS (run $RUN_ID, elapsed ${ELAPSED}s)..."
              sleep $POLL_INTERVAL
              ELAPSED=$((ELAPSED + POLL_INTERVAL))
            done

            if [ $ELAPSED -ge $TIMEOUT ]; then
              echo "  TIMEOUT waiting for staging: $wf"
              exit 1
            fi
          done

          echo ""
          echo "=== All staging deployments completed successfully ==="

  production:
    needs: staging
    runs-on: ubuntu-latest
    env:
      GH_REPO: ${{ github.repository }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Trigger production deployments
        id: trigger_production
        run: |
          set -eo pipefail
          WORKFLOWS='${{ github.event.inputs.workflows }}'
          COUNT=$(echo "$WORKFLOWS" | jq length)
          echo "All $COUNT staging run(s) passed. Triggering production..."

          TRIGGER_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "trigger_time=$TRIGGER_TIME" >> $GITHUB_OUTPUT

          readarray -t WF_ARRAY < <(echo "$WORKFLOWS" | jq -r '.[]')
          for wf in "${WF_ARRAY[@]}"; do
            echo "Triggering production: $wf"
            gh workflow run "$wf" --field environment=production \
              || { echo "FATAL: Failed to trigger $wf — aborting"; exit 1; }
            echo "  -> Triggered OK"
            sleep 5
          done

      - name: Wait for all production runs to complete
        run: |
          set -eo pipefail
          WORKFLOWS='${{ github.event.inputs.workflows }}'
          TRIGGER_TIME='${{ steps.trigger_production.outputs.trigger_time }}'
          POLL_INTERVAL=60
          TIMEOUT=5400

          echo "Waiting 90s for production runs to appear..."
          sleep 90

          readarray -t WF_ARRAY < <(echo "$WORKFLOWS" | jq -r '.[]')
          for wf in "${WF_ARRAY[@]}"; do
            echo "--- Polling: $wf (runs created after $TRIGGER_TIME) ---"
            ELAPSED=90

            while [ $ELAPSED -lt $TIMEOUT ]; do
              RUN_JSON=$(gh run list --workflow="$wf" --limit 5 \
                --json status,conclusion,databaseId,createdAt 2>/dev/null \
                | jq --arg since "$TRIGGER_TIME" \
                    '[.[] | select(.createdAt >= $since)]' \
                || echo "[]")

              if [ "$RUN_JSON" = "[]" ] || [ "$(echo "$RUN_JSON" | jq length)" = "0" ]; then
                echo "  Run not visible yet (elapsed ${ELAPSED}s)..."
                sleep $POLL_INTERVAL
                ELAPSED=$((ELAPSED + POLL_INTERVAL))
                continue
              fi

              STATUS=$(echo "$RUN_JSON" | jq -r '.[0].status')
              RUN_ID=$(echo "$RUN_JSON" | jq -r '.[0].databaseId')

              if [ "$STATUS" = "completed" ]; then
                CONCLUSION=$(echo "$RUN_JSON" | jq -r '.[0].conclusion')
                if [ "$CONCLUSION" = "success" ]; then
                  echo "  Production PASSED: $wf (run $RUN_ID)"
                else
                  echo "  Production FAILED: $wf (run $RUN_ID, conclusion: $CONCLUSION)"
                  exit 1
                fi
                break
              fi

              echo "  Status: $STATUS (run $RUN_ID, elapsed ${ELAPSED}s)..."
              sleep $POLL_INTERVAL
              ELAPSED=$((ELAPSED + POLL_INTERVAL))
            done

            if [ $ELAPSED -ge $TIMEOUT ]; then
              echo "  TIMEOUT waiting for production: $wf"
              exit 1
            fi
          done

          echo ""
          echo "=== All production deployments completed successfully ==="

  finalize:
    needs: production
    runs-on: ubuntu-latest
    steps:
      - name: Checkout workflows repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.REPO_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Update scan state and manifest
        run: |
          python3 << 'PYEOF'
          import json
          from datetime import datetime, timezone

          now = datetime.now(timezone.utc).isoformat()

          # Update scan state
          state = {
              "last_scanned_sha": "${{ github.event.inputs.content_sha }}",
              "last_scan_time": now,
          }
          with open("scripts/deploy/scan_state.json", "w") as f:
              json.dump(state, f, indent=2)
          print(f"Updated scan_state.json: SHA={state['last_scanned_sha']}")

          # Update manifest
          try:
              with open("scripts/deploy/deploy_manifest.json", "r") as f:
                  manifest = json.load(f)
              manifest["staging_status"] = "completed"
              manifest["production_status"] = "completed"
              manifest["completed_at"] = now
              with open("scripts/deploy/deploy_manifest.json", "w") as f:
                  json.dump(manifest, f, indent=2)
              print("Updated deploy_manifest.json with completion status")
          except Exception as e:
              print(f"Warning: Could not update manifest: {e}")
          PYEOF

      - name: Commit state update
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add scripts/deploy/scan_state.json scripts/deploy/deploy_manifest.json
          git diff --cached --quiet || git commit -m "Scan state: deployment completed $(date -u +%Y-%m-%d)"
          git pull --rebase
          git push
